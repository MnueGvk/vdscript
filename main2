-- ============================================
-- 1. SERVICIOS Y BIBLIOTECAS
-- ============================================

local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local LP = Players.LocalPlayer
local UIS = ("UserInputService")

-- ============================================
-- 2. FUNCIONES UTILITARIAS
-- ============================================

local function alive(obj) return obj and obj.Parent ~= nil end
local function validPart(p) return p and p:IsA("BasePart") and alive(p) end
local function dist(a, b) return (a - b).Magnitude end
local function clamp(n, lo, hi) if n < lo then return lo elseif n > hi then return hi else return n end end
local function firstBasePart(inst)
    if not alive(inst) then return nil end
    if inst:IsA("BasePart") then return inst end
    if inst:IsA("Model") then
        if inst.PrimaryPart and inst.PrimaryPart:IsA("BasePart") and alive(inst.PrimaryPart) then
            return inst.PrimaryPart
        end
        local p = inst:FindFirstChildWhichIsA("BasePart", true)
        if validPart(p) then return p end
    end
    return nil
end

-- ============================================
-- 3. VARIABLES GLOBALES Y CACHE
-- ============================================

local playerCache = {}
local connections = {}
local espObjects = {}

local roleCache = {}
local playerColors = {}

local generatorCache = {
    items = {},
    lastUpdate = 0,
    updateInterval = 3.0
}

-- ============================================
-- 4. CONFIGURACIÓN DE COLORES
-- ============================================

local survivorColor = Color3.fromRGB(0, 255, 0)
local killerColor = Color3.fromRGB(255, 0, 0)
local spectatorColor = Color3.fromRGB(255, 255, 255)
local lobbyColor = Color3.fromRGB(200, 200, 200)
local generatorColor = Color3.fromRGB(0, 170, 255)

-- ============================================
-- 5. FUNCIONES DE DETECCIÓN DE ROLES
-- ============================================

local function getRole(p)
    if not p then return "Lobby" end
    if roleCache[p] then return roleCache[p] end
    
    local team = p.Team
    if not team then 
        roleCache[p] = "Lobby"
        return "Lobby"
    end
    
    local teamName = team.Name:lower()
    local role
    if teamName:find("killer") then 
        role = "Killer"
    elseif teamName:find("survivor") then 
        role = "Survivor"
    else
        role = "Lobby"
    end
    
    roleCache[p] = role
    return role
end

local function isSpectator(p)
    if not p then return true end
    if not p.Character then return true end
    local humanoid = p.Character:FindFirstChildOfClass("Humanoid")
    if humanoid and humanoid.Health <= 0 then return true end
    return p:GetAttribute("Spectator") == true
end

local function isInLobby(p)
    if not p then return true end
    if not p.Character then return true end
    local hrp = p.Character:FindFirstChild("HumanoidRootPart")  
    if hrp then
        local pos = hrp.Position
        if pos.Y < -100 then return true end
    end
    return getRole(p) == "Lobby"
end

local function getPlayerColor(p)
    if playerColors[p] then return playerColors[p] end
    
    local color
    if isInLobby(p) then 
        color = lobbyColor
    elseif isSpectator(p) then 
        color = spectatorColor
    elseif getRole(p) == "Killer" then 
        color = killerColor
    else 
        color = survivorColor
    end
    
    playerColors[p] = color
    return color
end

-- ============================================
-- 6. FUNCIONES DE ESP Y HIGHLIGHTS
-- ============================================

local function makeBillboard(text, color3, parent)
    if not parent then return nil end
    
    -- Usar cache para billboards existentes
    local existing = parent:FindFirstChild("ESP_Tag")
    if existing then
        local label = existing:FindFirstChild("Label")
        if label then
            label.Text = text
            label.TextColor3 = color3
        end
        existing.Enabled = true
        return existing
    end
    
    local g = Instance.new("BillboardGui")
    g.Name = "ESP_Tag"
    g.AlwaysOnTop = true
    g.Size = UDim2.new(0, 200, 0, 36)
    g.StudsOffset = Vector3.new(0, 3, 0)
    g.Enabled = true
    g.Parent = parent
    
    local l = Instance.new("TextLabel")
    l.Name = "Label"
    l.BackgroundTransparency = 1
    l.Size = UDim2.new(1, 0, 1, 0)
    l.Font = Enum.Font.GothamBold
    l.Text = text
    l.TextSize = 14
    l.TextColor3 = color3 or Color3.new(1, 1, 1)
    l.TextStrokeTransparency = 0
    l.TextStrokeColor3 = Color3.new(0, 0, 0)
    l.Parent = g
    
    table.insert(espObjects, g)
    return g
end

local function ensureHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    -- Usar cache de highlights
    local hl = model:FindFirstChild("ESP_Highlight")
    if hl then
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.5
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
        return hl
    end
    
    local success, result = pcall(function()
        local h = Instance.new("Highlight")
        h.Name = "ESP_Highlight"
        h.Adornee = model
        h.FillTransparency = 0.5
        h.OutlineTransparency = 0.2
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.FillColor = color
        h.OutlineColor = color
        h.Parent = model
        return h
    end)
    
    if success then 
        hl = result
        table.insert(espObjects, hl)
        return hl
    end
    
    return nil
end

local function clearHighlight(model)
    if model and model:FindFirstChild("ESP_Highlight") then
        local hl = model.ESP_Highlight
        pcall(function() hl:Destroy() end)
        for i = #espObjects, 1, -1 do
            if espObjects[i] == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

-- ============================================
-- 7. VENTANA RAYFIELD PRINCIPAL
-- ============================================

local Window = Rayfield:CreateWindow({
    Name = "LoreOnTop",
    LoadingTitle = "Violence District",
    LoadingSubtitle = "Hecho por kcha abuelas3000",
    ConfigurationSaving = {Enabled = false, FolderName = "ESP_Suite", FileName = "esp_config"},
    KeySystem = false
})

-- ============================================
-- 8. CREACIÓN DE PESTAÑAS
-- ============================================

local VisualTab = Window:CreateTab("Visual")
local SurvivorTab = Window:CreateTab("Survivors")
local KillerTab = Window:CreateTab("Killers")
local GraphicsTab = Window:CreateTab("Graphics")
local MiscTab = Window:CreateTab("Misc")

-- ============================================
-- 9. SISTEMA PLAYER ESP
-- ============================================

local playerESPEnabled = false
local nametagsEnabled = false 
local espLoopConn = nil
local lastPlayerESPUpdate = 0
local PLAYER_ESP_INTERVAL = 1.5

local function cleanStaleCache()
    local now = tick()
    for player, cache in pairs(playerCache) do
        if not player or not player.Parent or (now - (cache.lastUpdate or 0)) > 30 then
            cleanPlayerESP(player)
            playerCache[player] = nil
            roleCache[player] = nil
            playerColors[player] = nil
        end
    end
end

local function cleanPlayerESP(p)
    if not p then return end
    if p.Character then
        clearHighlight(p.Character)
        local head = p.Character:FindFirstChild("Head")
        if head and head:FindFirstChild("ESP_Tag") then
            head.ESP_Tag:Destroy()
        end
    end
    if playerCache[p] then
        playerCache[p] = nil
    end
end

local function applyOptimizedPlayerESP(p)
    if p == LP then return end
    
    local character = p.Character
    if not (character and alive(character)) then
        cleanPlayerESP(p)
        return
    end
    
    local cache = playerCache[p]
    local now = tick()
    
    if cache then
  
        local timeSinceUpdate = now - cache.lastUpdate
        local currentIsLobby = isInLobby(p)
        local currentIsSpec = isSpectator(p)
        
        if timeSinceUpdate < PLAYER_ESP_INTERVAL and 
           currentIsLobby == cache.isLobby and 
           currentIsSpec == cache.isSpectator then
            return
        end
    end
    
    local color = getPlayerColor(p)
    local isLobby = isInLobby(p)
    local isSpec = isSpectator(p)
    
    if playerESPEnabled then
        ensureHighlight(character, color)
    else
        clearHighlight(character)
    end
    
    if nametagsEnabled then
        local head = character:FindFirstChild("Head")
        if head and validPart(head) then
            local text = p.Name
            if isLobby then text = text .. " [LOBBY]" end
            if isSpec then text = text .. " [ESPECTADOR]" end
            
            local existingTag = head:FindFirstChild("ESP_Tag")
            if not existingTag then
                makeBillboard(text, color, head)
            else
                local label = existingTag:FindFirstChild("Label")
                if label then
                    label.Text = text
                    label.TextColor3 = color
                end
                existingTag.Enabled = true
            end
        end
    elseif character and character:FindFirstChild("Head") then
        local head = character.Head
        if head and head:FindFirstChild("ESP_Tag") then
            head.ESP_Tag.Enabled = false
        end
    end
    
    playerCache[p] = {
        lastUpdate = now,
        character = character,
        color = color,
        isLobby = isLobby,
        isSpectator = isSpec
    }
end

local function updateAllPlayersESP()
    if not (playerESPEnabled or nametagsEnabled) then return end
    
    local now = tick()
    if now - lastPlayerESPUpdate < PLAYER_ESP_INTERVAL then return end
    lastPlayerESPUpdate = now
    
    if now % 10 < 0.1 then
        cleanStaleCache()
    end
    
    for player, cacheData in pairs(playerCache) do
        if player and player.Parent then
            applyOptimizedPlayerESP(player)
        else
            cleanPlayerESP(player)
            playerCache[player] = nil
        end
    end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and not playerCache[player] and player.Character then
            applyOptimizedPlayerESP(player)
        end
    end
end

local function startOptimizedESPLoop()
    if espLoopConn then 
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    for player, _ in pairs(playerCache) do
        cleanPlayerESP(player)
    end
    playerCache = {}
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            applyOptimizedPlayerESP(player)
        end
    end
    
    espLoopConn = RunService.Heartbeat:Connect(function()
        updateAllPlayersESP()
    end)
end

local function stopOptimizedESPLoop()
    if espLoopConn then
        espLoopConn:Disconnect()
        espLoopConn = nil
    end
    
    for player, _ in pairs(playerCache) do
        cleanPlayerESP(player)
    end
    
    playerCache = {}
    roleCache = {}
    playerColors = {}
    lastPlayerESPUpdate = 0
end

local function setupPlayerWatchers()
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LP and not connections[p] then
            local playerConns = {}
            
            playerConns.characterAdded = p.CharacterAdded:Connect(function(character)
                task.wait(1.5)
                if playerESPEnabled or nametagsEnabled then
                    applyOptimizedPlayerESP(p)
                end
            end)
            
            playerConns.teamChanged = p:GetPropertyChangedSignal("Team"):Connect(function()
                task.wait(1)
                roleCache[p] = nil
                playerColors[p] = nil
                if playerESPEnabled or nametagsEnabled then
                    applyOptimizedPlayerESP(p)
                end
            end)
            
            connections[p] = playerConns
            
            if p.Character then
                task.spawn(function()
                    task.wait(1.5)
                    if playerESPEnabled or nametagsEnabled then
                        applyOptimizedPlayerESP(p)
                    end
                end)
            end
        end
    end
end

setupPlayerWatchers()

Players.PlayerAdded:Connect(function(p)
    if p ~= LP then
        task.wait(1.5)
        setupPlayerWatchers()
        if playerESPEnabled or nametagsEnabled then
            applyOptimizedPlayerESP(p)
        end
    end
end)

Players.PlayerRemoving:Connect(function(p)
    if connections[p] then
        for _, conn in pairs(connections[p]) do
            pcall(function() conn:Disconnect() end)
        end
        connections[p] = nil
    end
    cleanPlayerESP(p)
    playerCache[p] = nil
    roleCache[p] = nil
    playerColors[p] = nil
end)

-- Sección Player ESP
VisualTab:CreateSection("Player ESP")

VisualTab:CreateToggle({
    Name = "Players ESP",
    CurrentValue = false,
    Flag = "PlayerESP",
    Callback = function(s)
        playerESPEnabled = s
        if s or nametagsEnabled then
            startOptimizedESPLoop()
        else
            stopOptimizedESPLoop()
        end
    end
})

VisualTab:CreateToggle({
    Name = "Mostrar Nombres",
    CurrentValue = false,
    Flag = "Nametags",
    Callback = function(s)
        nametagsEnabled = s
        if s or playerESPEnabled then
            startOptimizedESPLoop()
        else
            stopOptimizedESPLoop()
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Survivor",
    Color = survivorColor,
    Flag = "SurvivorCol",
    Callback = function(c) 
        survivorColor = c
        playerColors = {}
        for player, data in pairs(playerCache) do
            if getRole(player) == "Survivor" then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Killer",
    Color = killerColor,
    Flag = "KillerCol",
    Callback = function(c) 
        killerColor = c 
        playerColors = {}
        for player, data in pairs(playerCache) do
            if getRole(player) == "Killer" then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Color Lobby",
    Color = lobbyColor,
    Flag = "LobbyCol",
    Callback = function(c) 
        lobbyColor = c 
        playerColors = {}
        for player, data in pairs(playerCache) do
            if isInLobby(player) then
                applyOptimizedPlayerESP(player)
            end
        end
    end
})

-- ============================================
-- 11. SISTEMA GENERATOR ESP
-- ============================================

local generatorESPEnabled = false
local generatorLoopConn = nil
local generatorObjects = {}
local lastGeneratorUpdate = 0
local GENERATOR_ESP_INTERVAL = 2.0

local function ensureGeneratorHighlight(model, color)
    if not (model and model:IsA("Model") and alive(model)) then return nil end
    
    local hl = model:FindFirstChild("Generator_Highlight")
    if hl then
        hl.FillColor = color
        hl.OutlineColor = color
        hl.FillTransparency = 0.7
        hl.OutlineTransparency = 0.2
        hl.Enabled = true
        return hl
    end
    
    local success, result = pcall(function()
        local h = Instance.new("Highlight")
        h.Name = "Generator_Highlight"
        h.Adornee = model
        h.FillTransparency = 0.7
        h.OutlineTransparency = 0.2
        h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
        h.FillColor = color
        h.OutlineColor = color
        h.Parent = model
        return h
    end)
    
    if success then 
        hl = result
        table.insert(espObjects, hl)
        return hl
    end
    
    return nil
end

local function clearGeneratorHighlight(model)
    if model and model:FindFirstChild("Generator_Highlight") then
        local hl = model.Generator_Highlight
        pcall(function() hl:Destroy() end)
        for i = #espObjects, 1, -1 do
            if espObjects[i] == hl then
                table.remove(espObjects, i)
                break
            end
        end
    end
end

local function getGeneratorProgress(model)
    local progress = model:GetAttribute("RepairProgress") or 
                     model:GetAttribute("Progress") or 
                     model:GetAttribute("CurrentProgress") or 0
    if progress <= 1 then progress = progress * 100 end
    return math.clamp(progress, 0, 100)
end

local function updateGeneratorESP()
    if not generatorESPEnabled then return end
    
    local now = tick()
    if now - lastGeneratorUpdate < GENERATOR_ESP_INTERVAL then return end
    lastGeneratorUpdate = now
    
    if now - generatorCache.lastUpdate > generatorCache.updateInterval then
        generatorCache.items = {}
        
        local searchFolders = {
            Workspace:FindFirstChild("Map"),
            Workspace:FindFirstChild("Map1"),
            Workspace:FindFirstChild("Generators"),
            Workspace
        }
        
        for _, folder in ipairs(searchFolders) do
            if folder then
                for _, obj in ipairs(folder:GetDescendants()) do
                    if #generatorCache.items >= 20 then break end
                    if obj:IsA("Model") and (obj.Name:lower():find("generator") or 
                       obj:GetAttribute("IsGenerator") == true) then
                        local basePart = firstBasePart(obj)
                        if basePart then
                            table.insert(generatorCache.items, {
                                model = obj,
                                part = basePart,
                                lastCheck = 0
                            })
                        end
                    end
                end
            end
        end
        
        generatorCache.lastUpdate = now
    end
    
    for model, data in pairs(generatorObjects) do
        if not alive(model) then
            clearGeneratorHighlight(model)
            if data.part and data.part:FindFirstChild("Generator_Tag") then
                data.part.Generator_Tag:Destroy()
            end
            generatorObjects[model] = nil
        end
    end
    
    for _, genData in ipairs(generatorCache.items) do
        local model = genData.model
        local basePart = genData.part
        
        if alive(model) and alive(basePart) then
            local cacheData = generatorObjects[model]
            local shouldUpdate = true
            
            if cacheData then
                shouldUpdate = (now - (cacheData.lastUpdate or 0)) > 2
            end
            
            if shouldUpdate then
                local progress = getGeneratorProgress(model)
                local color
              
                if progress >= 100 then 
                    color = Color3.fromRGB(0, 255, 0)
                elseif progress >= 70 then 
                    color = Color3.fromRGB(100, 255, 100)
                elseif progress >= 40 then 
                    color = Color3.fromRGB(255, 255, 0)
                else 
                    color = Color3.fromRGB(255, 50, 50)
                end
                
                ensureGeneratorHighlight(model, color)
                
                local existingTag = basePart:FindFirstChild("Generator_Tag")
                if not existingTag then
                    local bb = Instance.new("BillboardGui")
                    bb.Name = "Generator_Tag"
                    bb.AlwaysOnTop = true
                    bb.Size = UDim2.new(0, 120, 0, 25)
                    bb.StudsOffset = Vector3.new(0, 4, 0)
                    bb.Enabled = true
                    bb.Parent = basePart
                    
                    local label = Instance.new("TextLabel")
                    label.Name = "Label"
                    label.BackgroundTransparency = 1
                    label.Size = UDim2.new(1, 0, 1, 0)
                    label.Font = Enum.Font.GothamMedium
                    label.Text = string.format("%.0f%%", progress)
                    label.TextSize = 11
                    label.TextColor3 = color
                    label.TextStrokeTransparency = 0.6
                    label.TextStrokeColor3 = Color3.new(0, 0, 0)
                    label.Parent = bb
                    
                    table.insert(espObjects, bb)
                else
                    local label = existingTag:FindFirstChild("Label")
                    if label then
                        label.Text = string.format("%.0f%%", progress)
                        label.TextColor3 = color
                    end
                end
                
                generatorObjects[model] = {
                    model = model,
                    part = basePart,
                    lastUpdate = now
                }
            end
        end
    end
end

local function startGeneratorESPLoop()
    if generatorLoopConn then return end
    
    task.wait(1.5)
    updateGeneratorESP()
    
    generatorLoopConn = RunService.Heartbeat:Connect(function()
        updateGeneratorESP()
    end)
end

local function stopGeneratorESPLoop()
    if generatorLoopConn then
        generatorLoopConn:Disconnect()
        generatorLoopConn = nil
    end
    
    for model, data in pairs(generatorObjects) do
        if data and data.model then
            clearGeneratorHighlight(data.model)
            if data.part and data.part:FindFirstChild("Generator_Tag") then
                data.part.Generator_Tag:Destroy()
            end
        end
    end
    
    generatorObjects = {}
    lastGeneratorUpdate = 0
    
    for i = #espObjects, 1, -1 do
        local obj = espObjects[i]
        if obj and (obj.Name == "Generator_Tag" or obj.Name == "Generator_Highlight") then
            pcall(function() obj:Destroy() end)
            table.remove(espObjects, i)
        end
    end
end

-- Sección Generator ESP
VisualTab:CreateSection("Generator ESP")

VisualTab:CreateToggle({
    Name = "Generator ESP",
    CurrentValue = false,
    Flag = "GeneratorESP",
    Callback = function(s)
        generatorESPEnabled = s
        if s then 
            startGeneratorESPLoop() 
        else 
            stopGeneratorESPLoop() 
        end
    end
})

VisualTab:CreateColorPicker({
    Name = "Generator Color",
    Color = generatorColor,
    Flag = "GenCol",
    Callback = function(c) 
        generatorColor = c 
    end
})

-- ============================================
-- 12. SISTEMA SPEED BOOST
-- ============================================

local speedBoostEnabled = false
local speedBoostLevel = 1
local speedBoostValues = {1.05, 1.1, 1.2, 1.3, 1.4, 1.5}
local speedBoostConnection = nil
local originalWalkspeed = 16
local characterAddedConnection = nil
local isInVaultAnimation = false
local lastAnimationCheck = 0

local function checkVaultAnimation()
    local char = LP.Character
    if not char then return false end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if animator then
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            local animName = track.Animation.Name:lower()
            if animName:find("vault") or animName:find("window") or animName:find("pallet") then
                return true
            end
        end
    end
    
    return false
end

local function applySpeedBoost()
    local char = LP.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if originalWalkspeed == 16 then
                originalWalkspeed = humanoid.WalkSpeed
            end
            
            local currentTime = tick()
            if currentTime - lastAnimationCheck > 1 then
                isInVaultAnimation = checkVaultAnimation()
                lastAnimationCheck = currentTime
            end
            
            if speedBoostEnabled then
                local boostMultiplier = speedBoostValues[speedBoostLevel] or 1.05
                local newSpeed = originalWalkspeed * boostMultiplier
                
                if isInVaultAnimation then
                    humanoid.WalkSpeed = originalWalkspeed
                else
                    humanoid.WalkSpeed = newSpeed
                end
                
                pcall(function()
                    char:SetAttribute("speedboost", boostMultiplier)
                    char:SetAttribute("IsRunning", true)
                end)
            else
                humanoid.WalkSpeed = originalWalkspeed
                
                pcall(function()
                    char:SetAttribute("speedboost", nil)
                    char:SetAttribute("IsRunning", false)
                end)
            end
        end
    end
end

local function maintainSpeedBoost()
    if speedBoostConnection then
        speedBoostConnection:Disconnect()
    end
    
    speedBoostConnection = RunService.Heartbeat:Connect(function()
        if not speedBoostEnabled then return end
        applySpeedBoost()
    end)
    
    applySpeedBoost()
end

local function cleanupSpeedBoost()
    if speedBoostConnection then
        speedBoostConnection:Disconnect()
        speedBoostConnection = nil
    end
    
    if characterAddedConnection then
        characterAddedConnection:Disconnect()
        characterAddedConnection = nil
    end
    
    local char = LP.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.WalkSpeed = originalWalkspeed
        end
        
        pcall(function()
            char:SetAttribute("speedboost", nil)
            char:SetAttribute("IsRunning", false)
        end)
    end
    
    isInVaultAnimation = false
    lastAnimationCheck = 0
end

-- Sección Speed Boost
SurvivorTab:CreateSection("Speed Boost")

SurvivorTab:CreateToggle({
    Name = "Speed Boost",
    CurrentValue = false,
    Flag = "SpeedBoostToggle",
    Callback = function(v)
        speedBoostEnabled = v
        
        if v then
            cleanupSpeedBoost()
            
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    originalWalkspeed = humanoid.WalkSpeed
                end
            end
            
            maintainSpeedBoost()
            
            characterAddedConnection = LP.CharacterAdded:Connect(function()
                task.wait(0.5)
                if speedBoostEnabled then
                    local char = LP.Character
                    if char then
                        local humanoid = char:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            originalWalkspeed = humanoid.WalkSpeed
                            applySpeedBoost()
                        end
                    end
                end
            end)
            
        else
            cleanupSpeedBoost()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Nivel Speed Boost",
    Range = {1, 6},
    Increment = 1,
    CurrentValue = speedBoostLevel,
    Flag = "SpeedBoostLevel",
    Callback = function(v)
        speedBoostLevel = math.floor(v)
        
        if speedBoostEnabled then
            applySpeedBoost()
        end
    end
})

-- ============================================
-- 13. GENERATOR BOOST
-- ============================================

local boostEnabled = false
local boostLevel = 1
local boostValues = {1.05, 1.1, 1.2, 1.3, 1.4, 1.5}
local boostLoop = nil

local generatorBoostCache = {
    items = {},
    lastUpdate = 0,
    updateInterval = 5
}

local function updateGeneratorBoostCache()
    local now = tick()
    if now - generatorBoostCache.lastUpdate < generatorBoostCache.updateInterval then
        return generatorBoostCache.items
    end
    
    generatorBoostCache.items = {}
    
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and obj.Name:lower():find("generator") then
            local part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
            if part then
                table.insert(generatorBoostCache.items, {
                    model = obj,
                    part = part,
                    lastCheck = 0
                })
            end
        end
    end
    
    generatorBoostCache.lastUpdate = now
    return generatorBoostCache.items
end

local lastAttributeUpdate = 0
local ATTRIBUTE_UPDATE_INTERVAL = 0.5

local function applyOptimizedBoost()
    if not boostEnabled then return end
    
    local char = LP.Character
    if not char then return end
    
    local now = tick()
    
    if now - lastAttributeUpdate > ATTRIBUTE_UPDATE_INTERVAL then
        pcall(function()
            char:SetAttribute("GroupProject", 3)
            char:SetAttribute("repairboost", boostValues[boostLevel])
            char:SetAttribute("IsRepairing", true)
        end)
        lastAttributeUpdate = now
    end
    
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    local playerPos = root.Position
    local nearestGen = nil
    local nearestDist = 20
    
    local generators = updateGeneratorBoostCache()
    
    for _, genData in ipairs(generators) do
        if genData.model and genData.model.Parent and genData.part and genData.part.Parent then
            local dist = (playerPos - genData.part.Position).Magnitude
            
            if dist < nearestDist then
                nearestDist = dist
                nearestGen = genData.model
                
                if dist < 5 then break end
            end
        else
            genData.model = nil
        end
    end
    
    if nearestGen then
        local current = nearestGen:GetAttribute("Progress") or 
                       nearestGen:GetAttribute("progress") or 0
        
        if current < 1 then
            current = current * 100
        end
        
        if current < 100 then
            local increment = 7.0 * boostValues[boostLevel]
            local newProgress = math.min(100, current + increment)
            
            pcall(function()
                nearestGen:SetAttribute("Progress", newProgress)
                nearestGen:SetAttribute("progress", newProgress)
                nearestGen:SetAttribute("CurrentProgress", newProgress)
            end)
        end
    end
end

local function startOptimizedBoost()
    if boostLoop then
        boostLoop:Disconnect()
        boostLoop = nil
    end
    
    boostLoop = RunService.Stepped:Connect(function()
        if boostEnabled then
            applyOptimizedBoost()
        end
    end)
    
    updateGeneratorBoostCache()
end

local function stopOptimizedBoost()
    if boostLoop then
        boostLoop:Disconnect()
        boostLoop = nil
    end
    
    pcall(function()
        local char = LP.Character
        if char then
            char:SetAttribute("GroupProject", nil)
            char:SetAttribute("repairboost", nil)
            char:SetAttribute("IsRepairing", nil)
        end
    end)
    
    generatorBoostCache.items = {}
    generatorBoostCache.lastUpdate = 0
end

SurvivorTab:CreateSection("Generator Boost")

SurvivorTab:CreateToggle({
    Name = "Generator Boost",
    CurrentValue = false,
    Callback = function(value)
        boostEnabled = value
        
        if value then
            startOptimizedBoost()
        else
            stopOptimizedBoost()
        end
    end
})

SurvivorTab:CreateSlider({
    Name = "Nivel Generator Boost",
    Range = {1, 6},
    Increment = 1,
    CurrentValue = 1,
    Callback = function(value)
        boostLevel = math.floor(value)
    end
})

-- ============================================
-- 15. SISTEMA NO SKILLCHECK
-- ============================================

local noSkillEnabled = false
local noSkillConnections = {}

local skillcheckNames2 = {
    "SkillCheckPromptGui",
    "SkillCheckPromptGui-con", 
    "SkillCheckEvent",
    "SkillCheckFailEvent",
    "SkillCheckResultEvent",
    "SkillCheck"
}

local skillcheckHash2 = {}
for _, name in ipairs(skillcheckNames2) do
    skillcheckHash2[name:lower()] = true
end

local function isSkillCheck2(obj)
    if not obj then return false end
    local name = obj.Name:lower()
    if skillcheckHash2[name] then return true end
    return name:find("skillcheck") ~= nil
end

local function removeSkillCheck(obj)
    pcall(function()
        if obj:IsA("ProximityPrompt") then
            obj.Enabled = false
            obj.HoldDuration = 1e9
        end
        if obj:IsA("ScreenGui") or obj:IsA("SurfaceGui") or obj:IsA("BillboardGui") then
            obj.Enabled = false
            obj.Visible = false
        end
        obj:Destroy()
    end)
end

local function clearExistingSkillChecks()
    local places = {
        LP:FindFirstChild("PlayerGui"),
        StarterGui,
        ReplicatedStorage
    }
    for _, place in ipairs(places) do
        if place then
            for _, child in ipairs(place:GetDescendants()) do
                if isSkillCheck2(child) then
                    removeSkillCheck(child)
                end
            end
        end
    end
end

local function interceptSkillCheckCreation()
    for _, conn in pairs(noSkillConnections) do
        conn:Disconnect()
    end
    noSkillConnections = {}
    
    local playerGui = LP:FindFirstChild("PlayerGui")
    if playerGui then
        table.insert(noSkillConnections, playerGui.ChildAdded:Connect(function(child)
            if noSkillEnabled and isSkillCheck2(child) then
                removeSkillCheck(child)
            end
        end))
        table.insert(noSkillConnections, playerGui.DescendantAdded:Connect(function(descendant)
            if noSkillEnabled and isSkillCheck2(descendant) then
                removeSkillCheck(descendant)
            end
        end))
    end
    
    table.insert(noSkillConnections, StarterGui.ChildAdded:Connect(function(child)
        if noSkillEnabled and isSkillCheck2(child) then
            removeSkillCheck(child)
        end
    end))
    
    table.insert(noSkillConnections, ReplicatedStorage.DescendantAdded:Connect(function(descendant)
        if noSkillEnabled and isSkillCheck2(descendant) then
            removeSkillCheck(descendant)
        end
    end))
end

local function interceptSkillCheckRemotes()
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("RemoteEvent") or obj:IsA("RemoteFunction") then
            if isSkillCheck2(obj) then
                local originalFire = obj.FireServer
                obj.FireServer = function(self, ...)
                    if noSkillEnabled then
                        return true
                    end
                    return originalFire(self, ...)
                end
            end
        end
    end
end

SurvivorTab:CreateSection("Skill-Checks")

SurvivorTab:CreateToggle({
    Name = "No Skillchecks",
    CurrentValue = false,
    Flag = "NoSkill",
    Callback = function(v)
        noSkillEnabled = v
        if v then
            clearExistingSkillChecks()
            interceptSkillCheckCreation()
            interceptSkillCheckRemotes()
            table.insert(noSkillConnections, ReplicatedStorage.DescendantAdded:Connect(function(child)
                if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) and isSkillCheck2(child) then
                    interceptSkillCheckRemotes()
                end
            end))
        else
            for _, conn in pairs(noSkillConnections) do
                conn:Disconnect()
            end
            noSkillConnections = {}
        end
    end
})

-- ============================================
-- INSTA HEAL FORZADO
-- ============================================

local instaHealEnabled = false
local healConnection = nil

-- Variables
local lastHealCheck = 0
local HEAL_CHECK_INTERVAL = 0.2

-- Función principal de curación forzada
local function forceHealAllSurvivors()
    if not instaHealEnabled then return end
    
    local now = tick()
    if now - lastHealCheck < HEAL_CHECK_INTERVAL then return end
    lastHealCheck = now
    
    local myChar = LP.Character
    if not myChar then return end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    -- Curar a todos los survivors cercanos
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            local targetChar = player.Character
            local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
            
            -- Verificar distancia
            if targetRoot then
                local distance = (myRoot.Position - targetRoot.Position).Magnitude
                
                -- Si está cerca (radio 15) O si es el jugador local
                if distance <= 15 or player == LP then
                    
                    -- MÉTODO 1: Modificar atributos DIRECTAMENTE
                    pcall(function()
                        targetChar:SetAttribute("Health", 100)
                        targetChar:SetAttribute("CurrentHealth", 100)
                        targetChar:SetAttribute("HealProgress", 100)
                        targetChar:SetAttribute("IsHealing", true)
                        
                        -- Eliminar atributos de herido
                        targetChar:SetAttribute("Injured", false)
                        targetChar:SetAttribute("Downed", false)
                        targetChar:SetAttribute("Dying", false)
                    end)
                    
                    -- MÉTODO 2: Modificar Humanoid directamente
                    pcall(function()
                        local humanoid = targetChar:FindFirstChildOfClass("Humanoid")
                        if humanoid then
                            -- Guardar salud máxima si no la sabemos
                            if not humanoid.MaxHealth or humanoid.MaxHealth <= 0 then
                                humanoid.MaxHealth = 100
                            end
                            
                            -- Forzar salud al máximo
                            humanoid.Health = humanoid.MaxHealth
                            
                            -- Si está muerto, revivir
                            if humanoid:GetState() == Enum.HumanoidStateType.Dead then
                                humanoid:ChangeState(Enum.HumanoidStateType.Running)
                            end
                        end
                    end)
                    
                    -- MÉTODO 3: Buscar y modificar scripts de salud
                    pcall(function()
                        for _, script in ipairs(targetChar:GetDescendants()) do
                            if script:IsA("Script") or script:IsA("LocalScript") then
                                local scriptName = script.Name:lower()
                                if scriptName:find("health") or scriptName:find("heal") then
                                    -- Intentar modificar el entorno del script
                                    local success, env = pcall(getfenv, script)
                                    if success and env then
                                        if env.health then env.health = 100 end
                                        if env.Health then env.Health = 100 end
                                        if env.currentHealth then env.currentHealth = 100 end
                                        if env.CurrentHealth then env.CurrentHealth = 100 end
                                    end
                                end
                            end
                        end
                    end)
                    
                    -- MÉTODO 4: Modificar HumanoidRootPart también
                    pcall(function()
                        if targetRoot:IsA("BasePart") then
                            targetRoot:SetAttribute("IsHealing", true)
                            targetRoot:SetAttribute("HealProgress", 100)
                        end
                    end)
                    
                    -- MÉTODO 5: Buscar RemoteEvents y forzar su uso
                    pcall(function()
                        -- Buscar HealEvent en ReplicatedStorage
                        local remotesFolder = ReplicatedStorage:FindFirstChild("Remotes")
                        if remotesFolder then
                            local healingFolder = remotesFolder:FindFirstChild("Healing")
                            if healingFolder then
                                local healEvent = healingFolder:FindFirstChild("HealEvent")
                                if healEvent and healEvent:IsA("RemoteEvent") then
                                    healEvent:FireServer(targetChar, 100)
                                end
                            end
                        end
                    end)
                end
            end
        end
    end
end

-- Interceptar cuando alguien intenta dañar a los survivors
local function preventDamage()
    -- Buscar RemoteEvents de daño y prevenirlos
    for _, obj in ipairs(ReplicatedStorage:GetDescendants()) do
        if obj:IsA("RemoteEvent") then
            local name = obj.Name:lower()
            if name:find("damage") or name:find("hit") or name:find("attack") then
                local original = obj.FireServer
                
                obj.FireServer = function(self, ...)
                    local args = {...}
                    
                    if instaHealEnabled and #args >= 1 then
                        local target = args[1]
                        if typeof(target) == "Instance" and target:IsA("Model") then
                            -- Verificar si es un survivor
                            for _, player in ipairs(Players:GetPlayers()) do
                                if player.Character == target then
                                    -- Prevenir el daño
                                    return nil
                                end
                            end
                        end
                    end
                    
                    return original(self, ...)
                end
            end
        end
    end
end

-- Monitorear y mantener atributos constantemente
local function maintainHealthAttributes()
    if not instaHealEnabled then return end
    
    -- Forzar atributos en el jugador local también
    local myChar = LP.Character
    if myChar then
        pcall(function()
            myChar:SetAttribute("Health", 100)
            myChar:SetAttribute("CurrentHealth", 100)
            myChar:SetAttribute("HealProgress", 100)
            
            local humanoid = myChar:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.Health = humanoid.MaxHealth
            end
        end)
    end
end

-- Configurar sistema
local function setupForcedHealSystem()
    if healConnection then
        healConnection:Disconnect()
        healConnection = nil
    end
    
    -- Prevenir daño
    preventDamage()
    
    -- Iniciar loop de curación forzada
    healConnection = RunService.Heartbeat:Connect(function()
        forceHealAllSurvivors()
        maintainHealthAttributes()
    end)
    
    -- Forzar curación inmediata
    task.spawn(function()
        task.wait(0.5)
        forceHealAllSurvivors()
    end)
end

-- Limpiar sistema
local function cleanupForcedHealSystem()
    if healConnection then
        healConnection:Disconnect()
        healConnection = nil
    end
end


SurvivorTab:CreateSection("Insta Heal")

SurvivorTab:CreateToggle({
    Name = "Insta Heal",
    CurrentValue = false,
    Callback = function(v)
        instaHealEnabled = v
        
        if v then
            pcall(function()
                setupForcedHealSystem()
            end)
        else
            pcall(function()
                cleanupForcedHealSystem()
            end)
        end
    end
})

-- ============================================
-- 17. SISTEMA ANTI-RALENTIZACIÓN
-- ============================================

local antiRalentizacionEnabled = false
local antiRalentizacionConnection = nil
local jumpButtonConnection = nil
local originalWalkspeedAR = 16
local hiddenButtons = {}
local characterAddedConnectionAR = nil

local function cleanupConnectionsAR()
    if antiRalentizacionConnection then
        antiRalentizacionConnection:Disconnect()
        antiRalentizacionConnection = nil
    end
    
    if jumpButtonConnection then
        jumpButtonConnection:Disconnect()
        jumpButtonConnection = nil
    end
    
    if characterAddedConnectionAR then
        characterAddedConnectionAR:Disconnect()
        characterAddedConnectionAR = nil
    end
end

local function restoreButtons()
    for button, _ in pairs(hiddenButtons) do
        if button and button.Parent then
            button.Visible = true
            button.BackgroundTransparency = 0
            if button:IsA("TextButton") then
                button.TextTransparency = 0
            else
                button.ImageTransparency = 0
            end
            button.Active = true
            button.Selectable = true
        end
    end
    hiddenButtons = {}
end

local function hideJumpButtons()
    local playerGui = LP:FindFirstChild("PlayerGui")
    if not playerGui then return end
    
    for _, gui in ipairs(playerGui:GetDescendants()) do
        if gui:IsA("TextButton") or gui:IsA("ImageButton") then
            local name = gui.Name:lower()
            local text = (gui.Text or ""):lower()
            
            if name:find("jump") or name:find("saltar") or 
               text:find("jump") or text:find("saltar") or
               name:find("space") then
                
                if not hiddenButtons[gui] then
                    hiddenButtons[gui] = true
                    
                    gui.Visible = false
                    gui.BackgroundTransparency = 1
                    if gui:IsA("TextButton") then
                        gui.TextTransparency = 1
                    else
                        gui.ImageTransparency = 1
                    end
                    gui.Active = false
                    gui.Selectable = false
                end
            end
        end
    end
end

local function preventFallSlowdown()
    if antiRalentizacionConnection then
        antiRalentizacionConnection:Disconnect()
    end
    
    antiRalentizacionConnection = RunService.Heartbeat:Connect(function()
        if not antiRalentizacionEnabled then return end
        
        local char = LP.Character
        if not char then return end
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end
        
        if originalWalkspeedAR == 16 then
            originalWalkspeedAR = humanoid.WalkSpeed
        end
        
        local state = humanoid:GetState()
        
        if state == Enum.HumanoidStateType.Landed or
           state == Enum.HumanoidStateType.FallingDown or
           state == Enum.HumanoidStateType.GettingUp then
           
            humanoid:ChangeState(Enum.HumanoidStateType.Running)
            
            if humanoid.WalkSpeed < originalWalkspeedAR then
                humanoid.WalkSpeed = originalWalkspeedAR
            end
            
            pcall(function()
                char:SetAttribute("FallRecovery", 0)
                char:SetAttribute("StunDuration", 0)
                
                if char:GetAttribute("Immobile") == true then
                    char:SetAttribute("Immobile", false)
                end
                
                local animator = char:FindFirstChildOfClass("Animator")
                if animator then
                    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                        local animName = track.Animation.Name:lower()
                        if animName:find("stun") or animName:find("fall") or 
                           animName:find("recovery") then
                            track:Stop(0.1)
                        end
                    end
                end
            end)
        end
        
        if humanoid.WalkSpeed < originalWalkspeedAR then
            humanoid.WalkSpeed = originalWalkspeedAR
            
            pcall(function()
                char:SetAttribute("SlowDuration", 0)
                char:SetAttribute("StunDuration", 0)
                
                for _, effect in ipairs(char:GetChildren()) do
                    if effect:IsA("BoolValue") then
                        local nameLower = effect.Name:lower()
                        if nameLower:find("slow") or nameLower:find("stun") then
                            effect:Destroy()
                        end
                    end
                end
                
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    for _, force in ipairs(rootPart:GetChildren()) do
                        if force:IsA("BodyVelocity") then
                            local nameLower = force.Name:lower()
                            if nameLower:find("slow") or nameLower:find("stun") then
                                force:Destroy()
                            end
                        end
                    end
                end
            end)
        end
        
        if state == Enum.HumanoidStateType.Climbing or
           state == Enum.HumanoidStateType.Swimming or
           state == Enum.HumanoidStateType.Seated then
            return
        end
    end)
end

SurvivorTab:CreateSection("Anti-Ralentización")

SurvivorTab:CreateToggle({
    Name = "Anti-Ralentización",
    CurrentValue = false,
    Callback = function(v)
        antiRalentizacionEnabled = v
        
        cleanupConnectionsAR()
        restoreButtons()
        
        if v then
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    originalWalkspeedAR = humanoid.WalkSpeed
                end
            end
            
            preventFallSlowdown()
            
            task.spawn(function()
                task.wait(1)
                hideJumpButtons()
            end)
            
            local playerGui = LP:FindFirstChild("PlayerGui")
            if playerGui then
                jumpButtonConnection = playerGui.DescendantAdded:Connect(function(descendant)
                    if not antiRalentizacionEnabled then return end
                    
                    if descendant:IsA("TextButton") or descendant:IsA("ImageButton") then
                        local name = descendant.Name:lower()
                        local text = (descendant.Text or ""):lower()
                        
                        if name:find("jump") or name:find("saltar") or 
                           text:find("jump") or text:find("saltar") then
                            task.wait(1.5)
                            hideJumpButtons()
                        end
                    end
                end)
            end
            
            characterAddedConnectionAR = LP.CharacterAdded:Connect(function()
                if not antiRalentizacionEnabled then return end
                
                task.wait(1)
                
                local char = LP.Character
                if char then
                    local humanoid = char:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        originalWalkspeedAR = humanoid.WalkSpeed
                    end
                end
                
                task.wait(1)
                hideJumpButtons()
            end)
            
        else
            local char = LP.Character
            if char then
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid.WalkSpeed = originalWalkspeedAR
                end
            end
        end
    end
})

-- ============================================
-- SISTEMA MOONWALK MODE
-- ============================================

SurvivorTab:CreateSection("Moonwalk Mode")

local moonwalkEnabled = false
local moonwalkConnection = nil
local moonwalkInputConnections = {}
local UIS = game:GetService("UserInputService")

local maxTurn = 30
local turnSpeed = 350
local returnSpeed = 300
local baseYaw = 0
local currentYaw = 0
local turningLeft = false
local turningRight = false

local moonwalkButtonsGui = nil
local rButton = nil
local lButton = nil

local function getYaw(cf)
    local _, y, _ = cf:ToEulerAnglesYXZ()
    return math.deg(y)
end

local function setYaw(cf, yaw)
    local pos = cf.Position
    return CFrame.new(pos) * CFrame.Angles(0, math.rad(yaw), 0)
end

local function createMoonwalkButtons()
    if moonwalkButtonsGui then
        moonwalkButtonsGui:Destroy()
    end
    
    local PlayerGui = LP:FindFirstChild("PlayerGui")
    if not PlayerGui then return end
    
    moonwalkButtonsGui = Instance.new("ScreenGui")
    moonwalkButtonsGui.Name = "MoonwalkButtons"
    moonwalkButtonsGui.ResetOnSpawn = false
    moonwalkButtonsGui.IgnoreGuiInset = true
    moonwalkButtonsGui.Enabled = false
    moonwalkButtonsGui.Parent = PlayerGui
    
    rButton = Instance.new("TextButton")
    rButton.Name = "R_Button"
    rButton.Size = UDim2.new(0, 50, 0, 50)
    rButton.Position = UDim2.new(1, -120, 0.5, -25)
    rButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    rButton.TextColor3 = Color3.new(1, 1, 1)
    rButton.Text = "R"
    rButton.TextSize = 18
    rButton.Font = Enum.Font.GothamBold
    rButton.BorderSizePixel = 0
    rButton.AutoButtonColor = false
    rButton.Visible = false
    rButton.Parent = moonwalkButtonsGui
    
    lButton = Instance.new("TextButton")
    lButton.Name = "L_Button"
    lButton.Size = UDim2.new(0, 50, 0, 50)
    lButton.Position = UDim2.new(0, 20, 0.5, -25)
    lButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
    lButton.TextColor3 = Color3.new(1, 1, 1)
    lButton.Text = "L"
    lButton.TextSize = 18
    lButton.Font = Enum.Font.GothamBold
    lButton.BorderSizePixel = 0
    lButton.AutoButtonColor = false
    lButton.Visible = false
    lButton.Parent = moonwalkButtonsGui
    
    rButton.MouseButton1Down:Connect(function()
        rButton.BackgroundColor3 = Color3.fromRGB(0, 120, 200)
        turningRight = true
    end)
    
    rButton.MouseButton1Up:Connect(function()
        rButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        turningRight = false
    end)
    
    rButton.MouseLeave:Connect(function()
        rButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        turningRight = false
    end)
    
    lButton.MouseButton1Down:Connect(function()
        lButton.BackgroundColor3 = Color3.fromRGB(0, 120, 200)
        turningLeft = true
    end)
    
    lButton.MouseButton1Up:Connect(function()
        lButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        turningLeft = false
    end)
    
    lButton.MouseLeave:Connect(function()
        lButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        turningLeft = false
    end)
    
    return moonwalkButtonsGui
end

local function setButtonsVisibility(visible)
    if not moonwalkButtonsGui then
        createMoonwalkButtons()
    end
    
    moonwalkButtonsGui.Enabled = visible
    
    if rButton then
        rButton.Visible = visible
    end
    
    if lButton then
        lButton.Visible = visible
    end
    
    if not visible then
        if rButton then
            rButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        end
        if lButton then
            lButton.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        end
    end
end

local function cleanupMoonwalk()
    if moonwalkConnection then
        moonwalkConnection:Disconnect()
        moonwalkConnection = nil
    end
    
    for _, conn in pairs(moonwalkInputConnections) do
        if conn then
            conn:Disconnect()
        end
    end
    moonwalkInputConnections = {}
    
    local char = LP.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.AutoRotate = true
        end
    end
    
    turningLeft = false
    turningRight = false
    currentYaw = 0
    
    setButtonsVisibility(false)
end

local function startMoonwalk()
    cleanupMoonwalk()
    
    local char = LP.Character
    if not char then return end
    
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    local root = char:FindFirstChild("HumanoidRootPart")
    
    if not (humanoid and root) then return end
    
    humanoid.AutoRotate = false
    
    baseYaw = getYaw(root.CFrame)
    currentYaw = baseYaw
    
    setButtonsVisibility(true)
    
    moonwalkInputConnections.inputBegan = UIS.InputBegan:Connect(function(input)
        if not moonwalkEnabled then return end
        
        if input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.Left then
            turningLeft = true
        elseif input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.Right then
            turningRight = true
        end
    end)
    
    moonwalkInputConnections.inputEnded = UIS.InputEnded:Connect(function(input)
        if not moonwalkEnabled then return end
        
        if input.KeyCode == Enum.KeyCode.A or input.KeyCode == Enum.KeyCode.Left then
            turningLeft = false
        elseif input.KeyCode == Enum.KeyCode.D or input.KeyCode == Enum.KeyCode.Right then
            turningRight = false
        end
    end)
    
    moonwalkConnection = RunService.RenderStepped:Connect(function(dt)
        local currentChar = LP.Character
        if not currentChar then return end
        
        local currentRoot = currentChar:FindFirstChild("HumanoidRootPart")
        if not currentRoot then return end
        
        if turningLeft then
            currentYaw = currentYaw + turnSpeed * dt
            if currentYaw > baseYaw + maxTurn then
                currentYaw = baseYaw + maxTurn
            end
        elseif turningRight then
            currentYaw = currentYaw - turnSpeed * dt
            if currentYaw < baseYaw - maxTurn then
                currentYaw = baseYaw - maxTurn
            end
        else
            if currentYaw > baseYaw then
                currentYaw = currentYaw - returnSpeed * dt
                if currentYaw < baseYaw then 
                    currentYaw = baseYaw 
                end
            elseif currentYaw < baseYaw then
                currentYaw = currentYaw + returnSpeed * dt
                if currentYaw > baseYaw then 
                    currentYaw = baseYaw 
                end
            end
        end
        
        currentRoot.CFrame = setYaw(currentRoot.CFrame, currentYaw)
    end)
end

SurvivorTab:CreateToggle({
    Name = "Moonwalk Mode (Botones R/L)",
    CurrentValue = false,
    Flag = "MoonwalkToggle",
    Callback = function(enabled)
        moonwalkEnabled = enabled
        
        if enabled then
            startMoonwalk()
            
            LP.CharacterAdded:Connect(function()
                if moonwalkEnabled then
                    task.wait(0.5)
                    startMoonwalk()
                end
            end)
        else
            cleanupMoonwalk()
        end
    end
})

-- ============================================
-- SISTEMA ANTI-EFECTOS (KILLER TAB)
-- ============================================

KillerTab:CreateSection("Anti-Efectos")

local antiStunEnabled = false
local antiBlindEnabled = false
local antiStunConnection = nil
local antiBlindConnection = nil
local originalStunRemotes = {}
local originalBlindRemotes = {}
local remoteConnections = {}

local stunKeywords = {
    "stun", "knock", "daze", "hit", "stagger", "fall", "recovery",
    "down", "ragdoll", "immobile", "paralyze", "pallet", "wood",
    "plank", "board", "break", "slam", "impact", "stunbomb"
}

local blindKeywords = {
    "blind", "flash", "flashlight", "light", "flare", "flashbang",
    "flashgrenade", "strobe", "dazzle", "blinding", "glare", "beam"
}

local function containsKeywords(name, keywordList)
    local nameLower = name:lower()
    for _, keyword in ipairs(keywordList) do
        if nameLower:find(keyword) then
            return true
        end
    end
    return false
end

local function setupAntiStun()
    if antiStunConnection then
        antiStunConnection:Disconnect()
        antiStunConnection = nil
    end
    
    for remote, original in pairs(originalStunRemotes) do
        if remote and remote.Parent then
            remote.FireServer = original
        end
    end
    table.clear(originalStunRemotes)
    
    local function interceptStunRemotes()
        for _, remote in ipairs(game:GetDescendants()) do
            if remote:IsA("RemoteEvent") and not originalStunRemotes[remote] then
                local nameLower = remote.Name:lower()
                
                if containsKeywords(nameLower, stunKeywords) then
                    originalStunRemotes[remote] = remote.FireServer
                    
                    remote.FireServer = newcclosure(function(self, ...)
                        local args = {...}
                        
                        if antiStunEnabled then
                            for _, arg in ipairs(args) do
                                if type(arg) == "Instance" and arg:IsA("Model") then
                                    local char = LP.Character
                                    if char and (arg == char or arg:IsDescendantOf(char)) then
                                        return nil
                                    end
                                elseif type(arg) == "string" and containsKeywords(arg:lower(), stunKeywords) then
                                    return nil
                                end
                            end
                        end
                        
                        return originalStunRemotes[remote](self, ...)
                    end)
                end
            end
        end
    end
    
    for _, remoteFunc in ipairs(game:GetDescendants()) do
        if remoteFunc:IsA("RemoteFunction") and not originalStunRemotes[remoteFunc] then
            local nameLower = remoteFunc.Name:lower()
            
            if containsKeywords(nameLower, stunKeywords) then
                originalStunRemotes[remoteFunc] = remoteFunc.InvokeServer
                
                remoteFunc.InvokeServer = newcclosure(function(self, ...)
                    if antiStunEnabled then
                        local args = {...}
                        for _, arg in ipairs(args) do
                            if type(arg) == "Instance" and arg:IsA("Model") then
                                local char = LP.Character
                                if char and (arg == char or arg:IsDescendantOf(char)) then
                                    return false
                                end
                            end
                        end
                    end
                    
                    return originalStunRemotes[remoteFunc](self, ...)
                end)
            end
        end
    end
    
    antiStunConnection = RunService.Heartbeat:Connect(function()
        if not antiStunEnabled then return end
        
        local char = LP.Character
        if not char then return end
        
        local stunAttributes = {
            "IsStunned", "Stunned", "PalletStunned", "StunDuration", 
            "StunTime", "Knockdown", "KnockedDown", "Dazed", "Staggered",
            "Immobile", "FallingDown", "GettingUp", "RecoveryTime",
            "PalletHit", "StunnedByPallet", "PalletCooldown"
        }
        
        for _, attr in ipairs(stunAttributes) do
            pcall(function()
                if attr:find("Duration") or attr:find("Time") or attr:find("Cooldown") then
                    char:SetAttribute(attr, 0)
                else
                    char:SetAttribute(attr, false)
                end
            end)
        end
        
        for _, child in ipairs(char:GetDescendants()) do
            pcall(function()
                local nameLower = child.Name:lower()
                if containsKeywords(nameLower, stunKeywords) then
                    if child:IsA("ParticleEmitter") then
                        child.Enabled = false
                    elseif child:IsA("Sound") then
                        child:Stop()
                        child:Destroy()
                    elseif child:IsA("Script") or child:IsA("LocalScript") then
                        child.Disabled = true
                    elseif child:IsA("BodyVelocity") or child:IsA("BodyAngularVelocity") then
                        child:Destroy()
                    end
                end
            end)
        end
        
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            if humanoid.WalkSpeed < 16 then
                humanoid.WalkSpeed = 16
            end
            
            local state = humanoid:GetState()
            if state == Enum.HumanoidStateType.FallingDown or 
               state == Enum.HumanoidStateType.Ragdoll or
               state == Enum.HumanoidStateType.GettingUp then
                humanoid:ChangeState(Enum.HumanoidStateType.Running)
                humanoid.PlatformStand = false
                humanoid.Sit = false
            end
            
            humanoid.AutoRotate = true
            humanoid.JumpPower = 50
        end
        
        local animator = char:FindFirstChildOfClass("Animator")
        if animator then
            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                local animName = track.Animation.Name:lower()
                if containsKeywords(animName, stunKeywords) then
                    track:Stop(0)
                end
            end
        end
    end)
    
    interceptStunRemotes()
    
    local descAddedConnections = {}
    for _, location in ipairs({workspace, ReplicatedStorage, game:GetService("ReplicatedFirst")}) do
        if location then
            local conn = location.DescendantAdded:Connect(function(descendant)
                if antiStunEnabled and (descendant:IsA("RemoteEvent") or descendant:IsA("RemoteFunction")) then
                    if containsKeywords(descendant.Name:lower(), stunKeywords) then
                        task.wait(0.1)
                        interceptStunRemotes()
                    end
                end
            end)
            table.insert(descAddedConnections, conn)
        end
    end
    
    return descAddedConnections
end

local function setupAntiBlind()
    if antiBlindConnection then
        antiBlindConnection:Disconnect()
        antiBlindConnection = nil
    end
    
    for remote, original in pairs(originalBlindRemotes) do
        if remote and remote.Parent then
            remote.FireServer = original
        end
    end
    table.clear(originalBlindRemotes)
    
    local function interceptBlindRemotes()
        for _, remote in ipairs(game:GetDescendants()) do
            if remote:IsA("RemoteEvent") and not originalBlindRemotes[remote] then
                local nameLower = remote.Name:lower()
                
                if containsKeywords(nameLower, blindKeywords) then
                    originalBlindRemotes[remote] = remote.FireServer
                    
                    remote.FireServer = newcclosure(function(self, ...)
                        local args = {...}
                        
                        if antiBlindEnabled then
                            local char = LP.Character
                            if char then
                                for _, arg in ipairs(args) do
                                    if type(arg) == "Instance" and arg:IsA("Model") and 
                                       (arg == char or arg:IsDescendantOf(char)) then
                                        return nil
                                    end
                                end
                            end
                        end
                        
                        return originalBlindRemotes[remote](self, ...)
                    end)
                end
            end
        end
    end
    
    for _, remoteFunc in ipairs(game:GetDescendants()) do
        if remoteFunc:IsA("RemoteFunction") and not originalBlindRemotes[remoteFunc] then
            local nameLower = remoteFunc.Name:lower()
            
            if containsKeywords(nameLower, blindKeywords) then
                originalBlindRemotes[remoteFunc] = remoteFunc.InvokeServer
                
                remoteFunc.InvokeServer = newcclosure(function(self, ...)
                    if antiBlindEnabled then
                        local char = LP.Character
                        if char then
                            local args = {...}
                            for _, arg in ipairs(args) do
                                if type(arg) == "Instance" and arg:IsA("Model") and 
                                   (arg == char or arg:IsDescendantOf(char)) then
                                    return false
                                end
                            end
                        end
                    end
                    
                    return originalBlindRemotes[remoteFunc](self, ...)
                end)
            end
        end
    end
    
    antiBlindConnection = RunService.Heartbeat:Connect(function()
        if not antiBlindEnabled then return end
        
        local char = LP.Character
        if not char then return end
        
        local blindAttributes = {
            "Blinded", "FlashDuration", "BlindDuration", "FlashEffect",
            "StunnedByFlash", "FlashlightHit", "LightBlinded"
        }
        
        for _, attr in ipairs(blindAttributes) do
            pcall(function()
                if attr:find("Duration") then
                    char:SetAttribute(attr, 0)
                else
                    char:SetAttribute(attr, false)
                end
            end)
        end
        
        local playerGui = LP:FindFirstChild("PlayerGui")
        if playerGui then
            for _, gui in ipairs(playerGui:GetDescendants()) do
                pcall(function()
                    local nameLower = gui.Name:lower()
                    if containsKeywords(nameLower, blindKeywords) then
                        if gui:IsA("ScreenGui") or gui:IsA("Frame") or 
                           gui:IsA("ImageLabel") or gui:IsA("TextLabel") then
                            gui.Enabled = false
                            gui.Visible = false
                        end
                    end
                end)
            end
        end
        
        for _, child in ipairs(char:GetDescendants()) do
            pcall(function()
                local nameLower = child.Name:lower()
                if containsKeywords(nameLower, blindKeywords) then
                    if child:IsA("ParticleEmitter") then
                        child.Enabled = false
                        child:Destroy()
                    elseif child:IsA("Sound") then
                        child:Stop()
                        child:Destroy()
                    elseif child:IsA("Script") or child:IsA("LocalScript") then
                        child.Disabled = true
                    elseif child:IsA("Light") then
                        child.Enabled = false
                    end
                end
            end)
        end
        
        for _, effect in ipairs(workspace:GetDescendants()) do
            pcall(function()
                local nameLower = effect.Name:lower()
                if containsKeywords(nameLower, blindKeywords) then
                    if effect:IsA("ParticleEmitter") or effect:IsA("Explosion") then
                        effect:Destroy()
                    end
                end
            end)
        end
    end)
    
    interceptBlindRemotes()
    
    local descAddedConnections = {}
    for _, location in ipairs({workspace, ReplicatedStorage, game:GetService("ReplicatedFirst")}) do
        if location then
            local conn = location.DescendantAdded:Connect(function(descendant)
                if antiBlindEnabled and (descendant:IsA("RemoteEvent") or descendant:IsA("RemoteFunction")) then
                    if containsKeywords(descendant.Name:lower(), blindKeywords) then
                        task.wait(0.1)
                        interceptBlindRemotes()
                    end
                end
            end)
            table.insert(descAddedConnections, conn)
        end
    end
    
    return descAddedConnections
end

KillerTab:CreateToggle({
    Name = "Anti-Stun",
    CurrentValue = false,
    Callback = function(v)
        antiStunEnabled = v
        
        if v then
            local connections = setupAntiStun()
            remoteConnections["stun"] = connections
            
            LP.CharacterAdded:Connect(function()
                task.wait(1)
                if antiStunEnabled then
                    setupAntiStun()
                end
            end)
            
        else
            if antiStunConnection then
                antiStunConnection:Disconnect()
                antiStunConnection = nil
            end
            
            if remoteConnections["stun"] then
                for _, conn in ipairs(remoteConnections["stun"]) do
                    pcall(function() conn:Disconnect() end)
                end
                remoteConnections["stun"] = nil
            end
            
            for remote, original in pairs(originalStunRemotes) do
                if remote and remote.Parent then
                    remote.FireServer = original
                end
            end
            table.clear(originalStunRemotes)
        end
    end
})

KillerTab:CreateToggle({
    Name = "Anti-Blind",
    CurrentValue = false,
    Callback = function(v)
        antiBlindEnabled = v
        
        if v then
            local connections = setupAntiBlind()
            remoteConnections["blind"] = connections
            
            LP.CharacterAdded:Connect(function()
                task.wait(1)
                if antiBlindEnabled then
                    setupAntiBlind()
                end
            end)
            
        else
            if antiBlindConnection then
                antiBlindConnection:Disconnect()
                antiBlindConnection = nil
            end
            
            if remoteConnections["blind"] then
                for _, conn in ipairs(remoteConnections["blind"]) do
                    pcall(function() conn:Disconnect() end)
                end
                remoteConnections["blind"] = nil
            end
            
            for remote, original in pairs(originalBlindRemotes) do
                if remote and remote.Parent then
                    remote.FireServer = original
                end
            end
            table.clear(originalBlindRemotes)
        end
    end
})

-- ============================================
-- SISTEMA HITBOX EXPANDER
-- ============================================

KillerTab:CreateSection("Hitbox (Survivors)")

local hitboxExpanderEnabled = false
local hitboxSize = 15
local hitboxTransparency = 0.6
local hitboxColor = Color3.fromRGB(0, 255, 0)
local originalSizes = {}
local hitboxConnections = {}
local damageRemote = nil

local showHitboxVisual = false
local hitboxSpheres = {}
local hitboxLoopConnection = nil
local lastHitboxUpdate = 0
local HITBOX_UPDATE_INTERVAL = 0.05

local function getDamageRemote()
    if damageRemote then return damageRemote end
    
    for _, obj in ipairs(game:GetDescendants()) do
        if obj:IsA("RemoteEvent") then
            local nameLower = obj.Name:lower()
            if nameLower:find("damage") or nameLower:find("hit") or 
               nameLower:find("attack") or nameLower:find("take") then
                damageRemote = obj
                return damageRemote
            end
        end
    end
    return nil
end

local function applyDamageToPlayer(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return end
    
    local remote = getDamageRemote()
    if remote then
        pcall(function()
            remote:FireServer(targetPlayer.Character, "Hit", 50)
        end)
    end
end

local function applyHitboxExpander()
    if not hitboxExpanderEnabled then return end
    
    local myChar = LP.Character
    if not myChar then return end
    
    local myRoot = myChar:FindFirstChild("HumanoidRootPart")
    if not myRoot then return end
    
    if not showHitboxVisual then
        for _, sphere in pairs(hitboxSpheres) do
            if sphere and sphere.Parent then
                sphere:Destroy()
            end
        end
        hitboxSpheres = {}
    end
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP and player.Character then
            local head = player.Character:FindFirstChild("Head")
            local targetRoot = player.Character:FindFirstChild("HumanoidRootPart")
            
            if head and targetRoot then

                if not originalSizes[head] then
                    originalSizes[head] = {
                        Size = head.Size,
                        Transparency = head.Transparency,
                        CanCollide = head.CanCollide,
                        Color = head.Color,
                        Material = head.Material
                    }
                end
                
                head.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                head.Transparency = 1.0
                head.CanCollide = false
                head.Color = hitboxColor
                head.Material = Enum.Material.Neon
                
                pcall(function()
                    for _, child in ipairs(head:GetChildren()) do
                        if child:IsA("Decal") or child:IsA("SpecialMesh") then
                            child.Transparency = 1.0
                        end
                    end
                end)
                
                if showHitboxVisual then
                    if not hitboxSpheres[player] then
                        local sphere = Instance.new("Part")
                        sphere.Name = "HitboxSphere_" .. player.Name
                        sphere.Shape = Enum.PartType.Ball
                        sphere.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                        sphere.Transparency = hitboxTransparency
                        sphere.Color = hitboxColor
                        sphere.Material = Enum.Material.Neon
                        sphere.CanCollide = false
                        sphere.Anchored = true
                        sphere.Parent = workspace
                        
                        hitboxSpheres[player] = sphere
                    end
                    
                    local sphere = hitboxSpheres[player]
                    if sphere then
                        sphere.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
                        sphere.CFrame = head.CFrame
                        sphere.Color = hitboxColor
                        sphere.Transparency = hitboxTransparency
                    end
                else
                    if hitboxSpheres[player] then
                        hitboxSpheres[player]:Destroy()
                        hitboxSpheres[player] = nil
                    end
                end
                
                local distance = (myRoot.Position - targetRoot.Position).Magnitude
                if distance <= hitboxSize * 1.2 then
                    applyDamageToPlayer(player)
                end
            end
        else
            if hitboxSpheres[player] then
                hitboxSpheres[player]:Destroy()
                hitboxSpheres[player] = nil
            end
        end
    end
end

local function restoreOriginalHitboxes()
    for part, data in pairs(originalSizes) do
        if part and part.Parent then
            pcall(function()
                part.Size = data.Size
                part.Transparency = data.Transparency
                part.CanCollide = data.CanCollide
                part.Color = data.Color
                part.Material = data.Material or Enum.Material.Plastic
                
                for _, child in ipairs(part:GetChildren()) do
                    if child:IsA("Decal") or child:IsA("SpecialMesh") then
                        child.Transparency = data.Transparency
                    end
                end
            end)
        end
    end
    originalSizes = {}
    
    for _, sphere in pairs(hitboxSpheres) do
        if sphere and sphere.Parent then
            sphere:Destroy()
        end
    end
    hitboxSpheres = {}
end

local function startHitboxExpander()
    if hitboxLoopConnection then
        hitboxLoopConnection:Disconnect()
    end
    
    hitboxLoopConnection = RunService.Heartbeat:Connect(function(deltaTime)
        lastHitboxUpdate = lastHitboxUpdate + deltaTime
        if lastHitboxUpdate >= HITBOX_UPDATE_INTERVAL then
            applyHitboxExpander()
            lastHitboxUpdate = 0
        end
    end)
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LP then
            local conn = player.CharacterAdded:Connect(function(character)
                task.wait(1)
                if hitboxExpanderEnabled then
                    local head = character:FindFirstChild("Head")
                    if head and originalSizes[head] then
                        originalSizes[head] = nil
                    end
                    if hitboxSpheres[player] then
                        hitboxSpheres[player]:Destroy()
                        hitboxSpheres[player] = nil
                    end
                end
            end)
            table.insert(hitboxConnections, conn)
        end
    end
end

local function stopHitboxExpander()
    if hitboxLoopConnection then
        hitboxLoopConnection:Disconnect()
        hitboxLoopConnection = nil
    end
    
    restoreOriginalHitboxes()
    
    for _, conn in ipairs(hitboxConnections) do
        conn:Disconnect()
    end
    hitboxConnections = {}
end

KillerTab:CreateToggle({
    Name = "Hitbox Expander",
    CurrentValue = false,
    Flag = "HitboxExpanderToggle",
    Callback = function(v)
        hitboxExpanderEnabled = v
        
        if v then
            startHitboxExpander()
        else
            stopHitboxExpander()
        end
    end
})

KillerTab:CreateToggle({
    Name = "Mostrar Hitbox",
    CurrentValue = false,
    Flag = "ShowHitboxSpheres",
    Callback = function(v)
        showHitboxVisual = v
        
        if v and not hitboxExpanderEnabled then
            return
        end
    end
})

KillerTab:CreateSlider({
    Name = "Tamaño Hitbox",
    Range = {5, 50},
    Increment = 1,
    Suffix = " studs",
    CurrentValue = hitboxSize,
    Flag = "HitboxSizeSlider",
    Callback = function(v)
        hitboxSize = math.floor(v)
    end
})

KillerTab:CreateSlider({
    Name = "Transparencia",
    Range = {0.1, 0.9},
    Increment = 0.1,
    CurrentValue = hitboxTransparency,
    Flag = "HitboxTransparencySlider",
    Callback = function(v)
        hitboxTransparency = v
    end
})

KillerTab:CreateColorPicker({
    Name = "Color Hitbox",
    Color = hitboxColor,
    Flag = "HitboxColorPicker",
    Callback = function(v)
        hitboxColor = v
    end
})

-- ============================================
-- 21. SISTEMA FULL BREAK GENERATOR
-- ============================================
KillerTab:CreateSection("Generator")

local fullBreakEnabled = false

KillerTab:CreateToggle({
    Name = "Full Break Generator",
    CurrentValue = false,
    Callback = function(v)
        fullBreakEnabled = v
        if v then
            local originalRemoteEvents = {}
            
            local function interceptGeneratorRemotes()
                for _, remote in ipairs(game:GetService("ReplicatedStorage"):GetDescendants()) do
                    if remote:IsA("RemoteEvent") and not originalRemoteEvents[remote] then
                        local nameLower = remote.Name:lower()
                        if nameLower:find("generator") or nameLower:find("damage") or nameLower:find("kick") or 
                           nameLower:find("break") or nameLower:find("repair") then
                            
                            originalRemoteEvents[remote] = remote.FireServer
                            
                            remote.FireServer = newcclosure(function(self, ...)
                                local args = {...}
                                
                                if fullBreakEnabled and #args >= 2 then
                                    local target = args[1]
                                    local action = args[2]
                                    
                                    if typeof(target) == "Instance" and target:IsA("Model") then
                                        local targetName = target.Name:lower()
                                        
                                        if (targetName:find("generator") or targetName:find("gen_")) and 
                                           (action == "Damage" or action == "Kick" or action == "Break") then
                                            
                                            local modifiedArgs = {target, action, 100, true}
                                            for i = 3, #args do
                                                modifiedArgs[i] = args[i]
                                            end
                                            
                                            local success = pcall(function()
                                                return originalRemoteEvents[remote](self, unpack(modifiedArgs))
                                            end)
                                            
                                            task.spawn(function()
                                                task.wait(0.1)
                                                if target and target.Parent then
                                                    target:SetAttribute("Progress", 0)
                                                    target:SetAttribute("CurrentProgress", 0)
                                                    target:SetAttribute("Repaired", false)
                                                    target:SetAttribute("Broken", true)
                                                    
                                                    for _, scriptObj in ipairs(target:GetDescendants()) do
                                                        if scriptObj:IsA("Script") then
                                                            pcall(function()
                                                                local env = getfenv(scriptObj)
                                                                if env.Progress then
                                                                    env.Progress = 0
                                                                end
                                                                if env.currentProgress then
                                                                    env.currentProgress = 0
                                                                end
                                                            end)
                                                        end
                                                    end
                                                end
                                            end)
                                            
                                            return success
                                        end
                                    end
                                end
                                
                                return originalRemoteEvents[remote](self, ...)
                            end)
                        end
                    end
                end
            end
            
            local function interceptWorkspaceEvents()
                for _, remote in ipairs(workspace:GetDescendants()) do
                    if remote:IsA("RemoteEvent") and not originalRemoteEvents[remote] then
                        originalRemoteEvents[remote] = remote.FireServer
                        
                        remote.FireServer = newcclosure(function(self, ...)
                            local args = {...}
                            
                            if fullBreakEnabled and #args >= 2 then
                                local target = args[1]
                                local action = args[2]
                                
                                if typeof(target) == "Instance" and target:IsA("Model") then
                                    local targetName = target.Name:lower()
                                    
                                    if (targetName:find("generator") or targetName:find("gen_")) and 
                                       (action == "Damage" or action == "Kick" or action == "Break") then
                                        
                                        local modifiedArgs = {target, action, 100, true}
                                        for i = 3, #args do
                                            modifiedArgs[i] = args[i]
                                        end
                                        
                                        return originalRemoteEvents[remote](self, unpack(modifiedArgs))
                                    end
                                end
                            end
                            
                            return originalRemoteEvents[remote](self, ...)
                        end)
                    end
                end
            end
            
            local function interceptToolHit()
                local character = game.Players.LocalPlayer.Character
                if not character then return end
                
                for _, tool in ipairs(character:GetChildren()) do
                    if tool:IsA("Tool") then
                        for _, script in ipairs(tool:GetDescendants()) do
                            if script:IsA("LocalScript") then
                                pcall(function()
                                    local env = getfenv(script)
                                    if env.onHit then
                                        local originalOnHit = env.onHit
                                        env.onHit = function(target, ...)
                                            if fullBreakEnabled and target and target:IsA("Model") then
                                                local nameLower = target.Name:lower()
                                                if nameLower:find("generator") or nameLower:find("gen_") then
                                                  
                                                    task.wait(0.05)
                                                    pcall(function()
                                                        target:SetAttribute("Progress", 0)
                                                        target:SetAttribute("CurrentProgress", 0)
                                                    end)
                                                end
                                            end
                                            return originalOnHit(target, ...)
                                        end
                                    end
                                end)
                            end
                        end
                    end
                end
            end
            
            interceptGeneratorRemotes()
            interceptWorkspaceEvents()
            interceptToolHit()
            
            game.Players.LocalPlayer.CharacterAdded:Connect(function()
                task.wait(1)
                if fullBreakEnabled then
                    interceptToolHit()
                end
            end)
            
        end
    end
})

-- ============================================
-- 22. SISTEMA LOW GRAPHICS
-- ============================================

local lowGraphicsEnabled = false
local originalShadows = true

local function applySimpleLowGraphics()
    if not lowGraphicsEnabled then return end
    pcall(function()
        Lighting.GlobalShadows = false
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CastShadow = false
            end
        end
    end)
end

local function restoreSimpleGraphics()
    pcall(function()
        Lighting.GlobalShadows = originalShadows
        for _, part in ipairs(Workspace:GetDescendants()) do
            if part:IsA("BasePart") then
                part.CastShadow = true
            end
        end
    end)
end

GraphicsTab:CreateSection("Optimization")

GraphicsTab:CreateToggle({
    Name = "Low Graphics",
    CurrentValue = false,
    Flag = "NoShadows",
    Callback = function(s) 
        lowGraphicsEnabled = s
        if s then 
            originalShadows = Lighting.GlobalShadows
            applySimpleLowGraphics()
        else 
            restoreSimpleGraphics()
        end
    end
})

-- ============================================
-- 23. SISTEMA MISC
-- ============================================

MiscTab:CreateSection("Utilities")

MiscTab:CreateButton({
    Name = "Limpiar Todo",
    Callback = function()
        stopOptimizedESPLoop()
        stopGeneratorESPLoop()
        cleanupSpeedBoost()
        stopOptimizedBoost()
        
        for _, conn in pairs(noSkillConnections) do
            conn:Disconnect()
        end
        
        if healConnection then
            healConnection:Disconnect()
            healConnection = nil
        end
        
        if antiRalentizacionConnection then
            antiRalentizacionConnection:Disconnect()
            antiRalentizacionConnection = nil
        end
        
        if antiStunConnection then
            antiStunConnection:Disconnect()
            antiStunConnection = nil
        end
        
        if antiBlindConnection then
            antiBlindConnection:Disconnect()
            antiBlindConnection = nil
        end
        
        if hitboxLoopConnection then
            hitboxLoopConnection:Disconnect()
            hitboxLoopConnection = nil
        end
        
        for _, conn in pairs(hitboxConnections) do
            conn:Disconnect()
        end
        
        for _, obj in ipairs(espObjects) do
            pcall(function() obj:Destroy() end)
        end
        espObjects = {}
    end
})

-- ============================================
-- 24. INICIALIZACIÓN FINAL
-- ============================================

task.spawn(function()
    task.wait(2)
    Rayfield:LoadConfiguration()
end)
